"""
Модуль для зберігання константи ``DATA. Функція `_get_normalized_data()`
повертає нормалізований словник — готовий для імпорту в `main.py`.

Для створення словника `DATA` використовуються константи `_TEXT1`, `_TEXT2` та `_TEXT3`,
перелік яких можна поповнювати сирим (ненормалізованим) текстом.
Змінна `raw_data` утворює для ключа список з діапазонами підрядків (що роблячи зріз), які
гарантовано будуть присутні у тексті. Останній підрядок штучно неіснуючий.

Усі рядки нормалізуються у NFC при імпорті.
"""
from __future__ import annotations

import random as rnd
import unicodedata

# 1'000 символів
_TEXT1 = """Автори публiкації: Коваленко О.О., Корягіна Д.О. Вінницький національний технічний університет \
Анотація: У данній статті було розглянуто використання алгоритмів у бібліотеках мов програмування. Ключові \
слова: алгоритми, сортування, лінійний пошук, двійковий пошук, пошук стрибками, інтерполяційний пошук, \
експоненціальний пошук, жадібний алгоритм. Стаття За всю історію комп'ютерних наук склалося розуміння, \
які алгоритми та структури даних (способи їх зберігання) потрібні для вирішення практичних завдань, \
певний набір, який повинен знати кожен розробник. Наприклад, сортування: товари в магазині сортують \
за вартістю або терміну придатності, а ресторани – за віддаленістю або рейтингу. Хеш-таблиці допомагають \
перевірити коректність пароля та не зберігати його на сайті у відкритому вигляді, графи – знаходити \
найкоротший шлях і зберігати зв'язки між користувачами в соцмережах. Алгоритми – це послідовність точно \
визначених дій, які призводять до вирішення поставленої задачі чи певного завдання """

# 1'500 символів
_TEXT2 = """Метою роботи є виявлення найбільш популярних алгоритмів у бібліотеках мов програмування. \
Усі алгоритми та структури даних вже давно реалізовані в бібліотеках популярних мов програмування. \
Більше ніхто не пише вручну алгоритм сортування чисел, а щоб користуватися хеш-таблицями, навіть не \
потрібно знати, як вони влаштовані. Але наявність безлічі готових бібліотек не означає, що не потрібно \
розуміти, як влаштовані алгоритми. Фундаментальні знання допомагають дізнатися, що всередині, як воно \
працює і чому одне рішення краще, аніж інше у конкретній ситуації. Якщо зрозуміти, як влаштовані класичні \
алгоритми, то можна створювати власні рішення, комбінувати методи один з одним, щоб вирішувати більш \
складні завдання. У програмуванні стандартна бібліотека — це бібліотека, що доступна в усіх реалізаціях \
даної мови програмування. Зміст такої бібліотеки зазвичай описано у специфікації мови, однак також \
він може частково або повністю визначатися більш неформальними практиками програмістів, що користуються \
нею. Більшість стандартних бібліотек включають у себе визначення принаймні таких найчастіше використовуваних \
інструментів як: Алгоритми (такі як алгоритми сортування); Структури даних (наприклад, списки, дерева, \
хеш-таблиці); Взаємодія з відповідною платформою (введення-виведення, системні виклики та ін.). Пошук \
– поширена дія, яка виконується в бізнес-додатках. Розглянемо деякі реалізації відомих алгоритмів пошуку \
[2] на Java. Лінійний або послідовний пошук – найпростіший алгоритм пошуку"""

# 3'000 символів
_TEXT3 = """Жадібний алгоритм – метод розв'язання оптимізаційних задач, заснований на тому, що процес \
прийняття рішення можна розбити на елементарні кроки, на кожному з яких приймається окреме рішення. \
Рішення, прийняте на кожному кроці, має бути оптимальним тільки на поточному кроці та повинне прийматися \
без врахування попередніх або наступних рішень. У жадібному алгоритмі завжди робиться вибір, який здається \
найкращим у даний момент - тобто виробляється локально оптимальний вибір у надії, що він приведе до \
оптимального рішення глобальної задачі. Жадібні алгоритми не завжди приводять до оптимального рішення, \
але в багатьох завданнях вони дають потрібний результат. Цей алгоритм володіє достатньою потужністю \
та добре підходить для широкого класу задач. Алгоритми пошуку мінімальних остових дерев є класичним \
прикладом застосування жадібної стратегії [7]. Ознаки того, що задачу можливо вирішити за допомогою \
жадібного алгоритму: задачу можна розбити на підзадачі; величини, що розглядаються в задачі, можна \
дробити так само на підзадачі; сума оптимальних рішень для двох підзадач надає оптимальне рішення для \
всієї задачі. Розглянемо простий приклад завдання, що розв’язується жадібним алгоритмом: Наприклад, \
розглянемо проблему виплати 98 копійок монетами номіналом 1, 2, 5, 10 і 25 копійок так, щоб загальна \
кількість монет було мінімально. Рішення: Жадібний алгоритм у цьому випадку полягає в тому, щоб на \
кожному кроці побудови рішення використовувати монети максимального номіналу, і тим, щоб їх було якомога \
менше (досягнення локального мінімуму). Для початку необхідно три монети по 25 копійок (4 монети дають \
більшу суму, ніж потрібно). Залишається виплатити 98 – 25*3 = 23 копійки. На наступному кроці потрібно \
обрати чергові найбільші за номіналом монети, якими можна видати решту суми, — дві монети по 10 копійок. \
Два наступні кроки – це по одній монеті номіналом 1 і 2 копійки, тим самим дозволяючи виплатити всю \
суму 7 монетами. Висновки. Кожна система містить набір обмежень і вимог. Правильно підібраний алгоритм \
пошуку, що враховує ці обмеження відіграє визначальну роль у продуктивності системи. Алгоритми, призначені \
для вирішення завдань оптимізації, звичайно являють собою послідовність кроків, на кожному з яких надається \
деяка множина виборів. Визначення найкращого вибору, керуючись принципами динамічного програмування, \
у багатьох задачах оптимізації нагадує стрілянину з гармати по горобцях; іншими словами, для цих завдань \
краще підходять більш прості й ефективні алгоритми. Тому основне завдання програміста - аналізувати \
і вирішувати проблеми, де код - це всього лише інструмент досягнення мети. Часто виникають проблеми, \
які важко вирішити, тоді програмісту слід розробити новий алгоритм або поміркувати, як використовувати \
існуючий. Адже якщо знати про принципи роботи алгоритмів, тоді існує більша ймовірність знайти краще \
рішення. Іноді навіть нову проблему можна звести до старої, але для цього потрібно володіти фундаментальними \
знаннями. Вікіпедія GPGPU [Електронний р"""

# 50'000 символів перемішаних слів з попередніх текстів
_TEXT4 = ((_TEXT1 + _TEXT2 + " " + _TEXT3).split()) * 10
rnd.shuffle(_TEXT4)
_TEXT4 = " ".join(_TEXT4)[:50_000]

# Неіснуючий підрядок
_NOT_EXISITNG_TEXT = "ЦЬОГО РЯДКА НА 37 СИМВОЛІВ НЕ БУДЕ..."


def _get_normalized_data() -> dict[str, list[str]]:
    raw_data: dict[str, list[str]] = {
        # Тут вставляй свій сирий словник: "ключ" = текст для пошуку, значення = список підрядків.
        # Наразі шукаємо 4 присутніх підрядка різної довжини і в різних місцях, і неіснуючий підрядок на 37 символів.
        # =======> 8 символів       50 символів        100 символів      333 символа
        _TEXT1 : [_TEXT1[100:108], _TEXT1[ 600: 650], _TEXT1[-100:],     _NOT_EXISITNG_TEXT*9],
        _TEXT2 : [_TEXT2[100:108], _TEXT2[1200:1250], _TEXT2[-100:],     _NOT_EXISITNG_TEXT*9],
        _TEXT3 : [_TEXT3[100:108], _TEXT3[2000:2050], _TEXT3[-100:],     _NOT_EXISITNG_TEXT*9],
        # =======> 1000 символів        3000 символів          5000 символів       8880 символів
        _TEXT4 : [_TEXT4[5_000:6_000], _TEXT4[37_000:40_000], _TEXT4[-5000:],     _NOT_EXISITNG_TEXT*240],
    }

    result: dict[str, list[str]] = {}
    for key, patterns in raw_data.items():
        nk = unicodedata.normalize('NFC', key)
        nps: list[str] = [unicodedata.normalize('NFC', p) for p in patterns]
        result[nk] = nps
    return result

DATA = _get_normalized_data()